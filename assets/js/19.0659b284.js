(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{371:function(a,t,s){"use strict";s.r(t);var n=s(7),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环境"}},[a._v("#")]),a._v(" 环境")]),a._v(" "),s("p",[a._v("环境是从解析器角度出发，就是当前的环境中的符号集")]),a._v(" "),s("h3",{attrs:{id:"lambda-表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式"}},[a._v("#")]),a._v(" lambda 表达式")]),a._v(" "),s("p",[a._v("本质上是一种匿名函数\n(lambda (x) (x + 2)) 这是 Lisp 中的lambda写法，考虑里面的对变量的约束作用，可以分为两种 lambda 表达式：")]),a._v(" "),s("ol",[s("li",[a._v("Closed Lambda\n约束的符号都在lambda表达式中，自给自足")]),a._v(" "),s("li",[a._v("Opened Lambda\n其中存在符号不被 lambda 表达式约束，被定义在环境的符号集中，如 λx.x/y+2 中的 y\n我们可以通过环境来关闭一个 lambda (给未定义的符号赋值)")])]),a._v(" "),s("h3",{attrs:{id:"一个开放-lambda例子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一个开放-lambda例子"}},[a._v("#")]),a._v(" 一个开放 lambda例子")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("y")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" bar "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("在调用时y转为传入参数时确定的，而x是和环境有关，也就是自由变量")]),a._v(" "),s("h3",{attrs:{id:"开放的lambda是不能评估的（evaluate）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开放的lambda是不能评估的（evaluate）"}},[a._v("#")]),a._v(" 开放的lambda是不能评估的（evaluate）")]),a._v(" "),s("p",[a._v("由于开放的lambda中含有自由变量，因此解析器解析到这一步时没法评估出自由变量的值（或表达式），为了正确评估开放lambda，才有了闭包")]),a._v(" "),s("h3",{attrs:{id:"闭包真正的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包真正的定义"}},[a._v("#")]),a._v(" 闭包真正的定义")]),a._v(" "),s("p",[a._v("lambda表达式的闭包是定义在外部上下文（环境）中特定的符号集，它们给这个表达式中的自由符号赋值。它将一个开放的、仍然包含一些未定义的符号lambda表达式变为一个关闭的lambda表达式，使这个lambda表达式不再具有任何自由符号。")]),a._v(" "),s("h3",{attrs:{id:"关于流行语言中对闭包的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于流行语言中对闭包的定义"}},[a._v("#")]),a._v(" 关于流行语言中对闭包的定义")]),a._v(" "),s("p",[a._v("闭包”是他们用来实现词法作用域的一种特定技术，即一个函数可以访问它作用域外定义的变量。他们经常说函数“封闭（encloses）”这些变量，即捕获他们到某些数据结构去存储它们，防止它们在外部函数执行完后被销毁")]),a._v(" "),s("hr"),a._v(" "),s("h3",{attrs:{id:"funarg-problem"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#funarg-problem"}},[a._v("#")]),a._v(" FUNARG Problem")]),a._v(" "),s("p",[a._v("在实现高阶语言，也就是支持函数作为第一类的语言时，存在一个关于自由变量的实现难题")]),a._v(" "),s("h3",{attrs:{id:"词法作用域和动态作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域和动态作用域"}},[a._v("#")]),a._v(" 词法作用域和动态作用域")]),a._v(" "),s("p",[a._v("词法作用域也称为静态作用于，变量的作用范围取决于它在源代码中定义的位置，在词法解析阶段即可确定\n而动态作用域则相反，变量的作用范围取决于函数的调用链")]),a._v(" "),s("h3",{attrs:{id:"符号表栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号表栈"}},[a._v("#")]),a._v(" 符号表栈")]),a._v(" "),s("p",[a._v("在动态作用域的语言中，binding一般都使用符号表堆栈记录（symbol table stack），当函数调用时都会为它创建一张新的表记录去它当中定义的局部变量和形参，防止和函数外部的相同标识符混淆")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("A")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("A")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 打印 3")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 打印 2")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 这里有两个相同的符号 A，为了在执行时区分不同的A，符号表堆栈的做法是把环境记录到一张表中，然后子表和父表关联起来，实现调用链的效果")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用bar(1)时，会向上寻找符号表中的A=2，然后再调用foo，此时foo打印的A来自于bar环境中，因此打印的结果是3")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用foo()时，直接调用的是全局环境符号表中的A=2，因此打印的结果是2")]),a._v("\n")])])]),s("h3",{attrs:{id:"符号表树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号表树"}},[a._v("#")]),a._v(" 符号表树")]),a._v(" "),s("p",[a._v("符号表栈的作用可以解决存在多个符号的问题，但没法解决解决一开始遇到的存在自由变量的情况，这个问题就是 FUNARG Problem\n比起符号栈，符号表树多一个binding区域的表，表示自由变量的绑定关系，与当前符号表在同一级\n引用着子表的lambda表达式也被称为closure。")]),a._v(" "),s("h3",{attrs:{id:"再次总结闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再次总结闭包"}},[a._v("#")]),a._v(" 再次总结闭包")]),a._v(" "),s("p",[a._v("一个lambda表达式，没有绑定其它环境时，我们称它为open lambda，而绑定了其它环境的lambda表达式，我们称它们为闭包（closure），评估一个open lambda的结果就是一个闭包")]),a._v(" "),s("h3",{attrs:{id:"深约束和浅约束"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深约束和浅约束"}},[a._v("#")]),a._v(" 深约束和浅约束")]),a._v(" "),s("p",[a._v("符号表栈的方式，按照函数调用顺序遍历找到最近的与之相关的符号，我们称之为浅约束。\n符号表树的方式，将函数作为参数时，需要将自由变量在单独的一个环境中保存，然后该函数引用这个单独的环境，我们称之为深约束。而这样捆绑起来的整体也就是我们所说的闭包。")])])}),[],!1,null,null,null);t.default=r.exports}}]);