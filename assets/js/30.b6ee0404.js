(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{381:function(e,t,v){"use strict";v.r(t);var _=v(7),s=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"单向绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单向绑定"}},[e._v("#")]),e._v(" 单向绑定")]),e._v(" "),v("p",[e._v("传统web工程有一个View，对应着DOM结构；")]),e._v(" "),v("p",[e._v("有一个Model，对应着js中的数据对象；")]),e._v(" "),v("p",[e._v("单向绑定就是，Model变化了，View中的元素跟着变化；")]),e._v(" "),v("h2",{attrs:{id:"双向绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[e._v("#")]),e._v(" 双向绑定")]),e._v(" "),v("p",[e._v("双向绑定自然就是，除了上述过程外，View中元素变化也会引起Model变化，最典型的例子就是表单；")]),e._v(" "),v("h3",{attrs:{id:"同步dom结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步dom结构"}},[e._v("#")]),e._v(" 同步DOM结构")]),e._v(" "),v("p",[e._v("作为双向绑定的一个副作用，View和Model的数据是同步的；")]),e._v(" "),v("p",[e._v("想要达到这一点，")]),e._v(" "),v("ul",[v("li",[e._v("在Model变化，View变化，这一点很容易，操作DOM结构api就可以了")]),e._v(" "),v("li",[e._v("在View变化时，Model变化")])]),e._v(" "),v("p",[e._v("做到这一步需要监听View数据变化，基本数据结构用到 JavaScript语言本身提供了Proxy或者Object.observe()机制；")]),e._v(" "),v("p",[e._v("一个例外情况是数组的添加和删除行为无法感知，解决的方法是使用splice()方法，类似的方法有splice、push、unshift；")]),e._v(" "),v("p",[e._v("综合上面的讨论，双向绑定本质上就是 单向绑定 + 监听View变化，已经有几种实现方案，")]),e._v(" "),v("ul",[v("li",[e._v("发布者-订阅者模式（backbone.js）")]),e._v(" "),v("li",[e._v("脏值检查（angular.js）")]),e._v(" "),v("li",[e._v("数据劫持（vue.js）")])])])}),[],!1,null,null,null);t.default=s.exports}}]);