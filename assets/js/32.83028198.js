(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{382:function(s,t,a){"use strict";a.r(t);var n=a(7),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("怎么组织css，分为几种流派，")]),s._v(" "),a("h1",{attrs:{id:"语义化与视觉化，"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语义化与视觉化，"}},[s._v("#")]),s._v(" 语义化与视觉化，")]),s._v(" "),a("p",[s._v("演示(Presentational)：这里更趋向于将其称之为视觉类名，就是纯视觉。简单点说，视觉化类名是没有任何意思，就是根据视觉呈现的风格化，将其在HTML元素中声明类名。也就是说根据，视觉的表象，在HTML定义对应的类名，比如red、blue、mb10等\n语义化(Semantic):根据语义化在HTML中给元素定义类名。简单点说，就是根据功能模块，在HTML中定义类名，比如.user-registration或者.billing-info等")]),s._v(" "),a("h1",{attrs:{id:"oocss，"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oocss，"}},[s._v("#")]),s._v(" OOCSS，")]),s._v(" "),a("p",[s._v("面向对象的css，也就是考虑css扩展、继承\nOOCSS有一下缺点，\n大量使用演示类\n需要在模板中应用演示类\n样式(CSS)和结构(HTML)藕合太紧\n如果设计变动，需要更改CSS和HTML\n创建了数千行CSS，但有可能这些CSS永远不会被使用。比如Twitter Bootstrap")]),s._v(" "),a("p",[s._v("OOCSS风格是在实践中自然而然形成的，所暴露的缺点也是必然会出现")]),s._v(" "),a("h1",{attrs:{id:"oosass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oosass"}},[s._v("#")]),s._v(" OOSASS,")]),s._v(" "),a("p",[s._v("借助预编译的便利，可以做到对DOM结构提供语义化名称，对重用和继承则使用视觉化名称；\n没有CSS，只有Sass\n通过%placholder来声明视觉对象\n可以通过mixin创建可重复的CSS\n语义化的类名在DOM中声明，而视觉化类名在Sass中声明\n否则不可能使用CSS构建UI结构和框架\n通过Sass来扩展类，而不是通过DOM来扩展类")])])}),[],!1,null,null,null);t.default=r.exports}}]);