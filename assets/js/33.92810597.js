(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{383:function(n,t,e){"use strict";e.r(t);var i=e(7),a=Object(i.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("盒子模型涉及到 尺寸（width/height）和间距（padding/margin）;\n一般只有两种使用套路：\n只用width，然后让布局居中；控制父布局大小\n只用padding/margin,width不设置或设置为auto；让子布局自动扩充")]),n._v(" "),e("p",[n._v("尺寸和间距不会直接影响\n添加padding属性不会让实际显示效果变大；")]),n._v(" "),e("p",[n._v("padding 属性不起作用？\n当子布局是文本元素时，子布局宽度好像不会被父布局约束一样，出现文本穿透的效果；\n实际上父布局此时的padding依然生效，只是对于超过尺寸的子布局需要考虑覆盖问题；\n如果不想显示超过的内容，overflow:hidden;\n如果先要内容可以滚动，overflow:auto;等等")]),n._v(" "),e("p",[n._v("盒子模型和flex布局同时设置\n两者可以认为是单独考虑的系统；")])])}),[],!1,null,null,null);t.default=a.exports}}]);